@page "/"
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<PageTitle>AINovelistViewer</PageTitle>

<div class="mb-3">
    <label for="formFile" class="form-label">AIのべりすとファイル(.novel)を選択してください</label>
    <InputFile class="form-control" type="file" accept=".novel" Onchange="@HandleFileSelected" />
</div>

@if(isFileLoaded)
{
    <dl class="row">
        <dt class="col-sm-3">タイトル</dt>
        <dd class="col-sm-9">@title</dd>
        <dt class="col-sm-3">保存日時</dt>
        <dd class="col-sm-9">@saveDateTime</dd>
    </dl>

    <div class="row row-gap-3">
        <div class="d-flex justify-content-evenly">
            <button type="button" class="btn btn-primary" @onclick="CopyToClipboard">本文をクリップボードにコピー</button>
            <button type="button" class="btn btn-primary" @onclick="ExportText">本文をテキストでエクスポート</button>
        </div>
    </div>

    <div class="row row-gap-3">
        <div class="d-flex flex-column">
            <p class="fs-3">本文</p>
            @foreach (var text in mainText.Split(Environment.NewLine))
            {
                <div class="text-start text-wrap">@text</div>
            }
        </div>
    </div>
}

@code {
    private bool isFileLoaded = false;

    private string mainText = "";
    private string memory = "";
    private string footnote = "";
    private List<string> paramters = new();
    private string characterBook = "";
    private string ngWords = "";
    private string title = "";
    private int id = 0;
    private string script = "";
    private string chatTemplate = "";
    private string uuid = "";
    private DateTime saveDateTime = DateTime.Now;

    private IJSObjectReference? clipboardObjectReference = null;
    private IJSObjectReference? exportTextObjectReference = null;

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (e.FileCount == 0)
        {
            return;
        }

        if (Path.GetExtension(e.File.Name) != ".novel")
        {
            return;
        }

        using var stream = e.File.OpenReadStream();
        using var reader = new StreamReader(stream, System.Text.Encoding.UTF8);

        string content = await reader.ReadToEndAsync();

        var sections = content.Split("<|endofsection|>");

        var rawText = System.Web.HttpUtility.HtmlDecode(sections[0]);

        mainText = System.Text.RegularExpressions.Regex.Replace(rawText.Replace("<br>", Environment.NewLine), "<.*?>", string.Empty);
        memory = sections[1];
        footnote = sections[2];
        paramters = sections[3].Split("<>").ToList();
        characterBook = sections[4];
        ngWords = sections[5];
        title = sections[6];
        id = int.Parse(sections[7]);
        script = sections[8];
        chatTemplate = sections[9];
        uuid = sections[12];
        saveDateTime = DateTimeOffset.FromUnixTimeMilliseconds(long.Parse(sections[13])).ToLocalTime().DateTime;

        isFileLoaded = true;
    }

    private async Task CopyToClipboard()
    {
        if (clipboardObjectReference is null)
        {
            clipboardObjectReference = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/clipboard.js");
        }

        await clipboardObjectReference.InvokeVoidAsync("copyText", mainText);
    }

    private async Task ExportText()
    {
        if (exportTextObjectReference is null)
        {
            exportTextObjectReference = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/file.js");
        }

        var stream = new MemoryStream();
        var fileName = $"{title}.txt";

        stream.Write(System.Text.Encoding.UTF8.GetBytes(mainText));

        stream.Seek(0, SeekOrigin.Begin);

        using var streamRef = new DotNetStreamReference(stream);

        await exportTextObjectReference.InvokeVoidAsync("downloadTextFile", fileName, streamRef);
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (clipboardObjectReference is not null)
        {
            try
            {
                await clipboardObjectReference.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }

        if (exportTextObjectReference is not null)
        {
            try
            {
                await exportTextObjectReference.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
            }
        }
    }
}